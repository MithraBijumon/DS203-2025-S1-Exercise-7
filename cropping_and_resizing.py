# -*- coding: utf-8 -*-
"""Cropping_and_Resizing.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Pa-QO_gxOHqRwdXqyBQApwyA2NkW4Nhn
"""

import cv2
import os
import numpy as np
# You will need to install the pulp library: pip install pulp
from pulp import LpProblem, LpMaximize, LpVariable, value, PULP_CBC_CMD

# --- CONFIGURATION ---
# Directory where your original raw images are stored
IMAGE_DIRECTORY = "images"
# Directory where the processed 800x600 images will be saved
OUTPUT_DIRECTORY = "preprocessed_images"
# Target dimensions
TARGET_WIDTH = 800
TARGET_HEIGHT = 600
TARGET_ASPECT_RATIO = TARGET_WIDTH / TARGET_HEIGHT

# --- HELPER FUNCTIONS ---

def get_image_files(directory):
    """Returns a sorted list of image files from a directory."""
    files = []
    for f in os.listdir(directory):
        if f.lower().endswith(('.png', '.jpg', '.jpeg')):
            files.append(os.path.join(directory, f))
    return sorted(files)

def optimize_area(image):
    """
    Uses a linear programming solver (pulp) to find the dimensions of the
    largest possible rectangle with the target aspect ratio that fits inside the image.
    """
    h, w, _ = image.shape

    # 1. Define the problem: We want to maximize the area.
    # Since Area = h * w and w is proportional to h, maximizing height is sufficient.
    prob = LpProblem("AspectRatioMaximizer", LpMaximize)

    # 2. Define the variables: The optimized height and width, which must be
    # less than or equal to the original image dimensions.
    h_optimized = LpVariable("Height", lowBound=0, upBound=h)
    w_optimized = LpVariable("Width", lowBound=0, upBound=w)

    # 3. Define the objective function
    prob += h_optimized, "Maximize_Height_To_Maximize_Area"

    # 4. Add the crucial constraint: The new width must be 4/3 of the new height.
    prob += w_optimized == h_optimized * TARGET_ASPECT_RATIO

    # 5. Solve the problem
    # The solver will find the maximum possible h_optimized that satisfies all bounds and constraints.
    prob.solve(PULP_CBC_CMD(msg=0)) # Suppress solver messages

    # Return the final integer values for height and width
    return int(value(h_optimized)), int(value(w_optimized))

def crop_image(image, optimized_h, optimized_w):
    """Crops the image to the optimized dimensions from the center."""
    original_h, original_w, _ = image.shape

    # Calculate the top-left corner for the crop
    y_offset = (original_h - optimized_h) // 2
    x_offset = (original_w - optimized_w) // 2

    # Perform the crop
    return image[y_offset:y_offset + optimized_h, x_offset:x_offset + optimized_w]


# --- MAIN SCRIPT ---

# --- Step 1: Check and Create Directories ---
if not os.path.exists(IMAGE_DIRECTORY):
    print(f"Error: The input directory '{IMAGE_DIRECTORY}' does not exist.")
    print("Please create it and place your raw images inside.")
    exit()

os.makedirs(OUTPUT_DIRECTORY, exist_ok=True)
print(f"Output will be saved to '{OUTPUT_DIRECTORY}' directory.")


# --- Step 2: Get Image Files ---
image_files = get_image_files(IMAGE_DIRECTORY)
if not image_files:
    print(f"Error: No images found in '{IMAGE_DIRECTORY}'.")
    exit()

print(f"Found {len(image_files)} images to process...")

# --- Step 3: Loop Through Images, Process, and Save ---
processed_count = 0
for image_path in image_files:
    basename = os.path.basename(image_path)

    image = cv2.imread(image_path)
    if image is None:
        print(f"Warning: Could not read image, skipping: {basename}")
        continue

    # Use the new optimization and cropping functions
    opt_h, opt_w = optimize_area(image)
    cropped_image = crop_image(image, opt_h, opt_w)

    # Resize the cropped image to 800x600, but only scale down
    if cropped_image.shape[1] > TARGET_WIDTH:
        final_image = cv2.resize(cropped_image, (TARGET_WIDTH, TARGET_HEIGHT), interpolation=cv2.INTER_AREA)
    else:
        # Keep the image as is if it's smaller than the target dimensions
        final_image = cropped_image

    # Construct the full output path
    output_path = os.path.join(OUTPUT_DIRECTORY, basename)

    # Save the processed image
    cv2.imwrite(output_path, final_image)
    processed_count += 1

print(f"\nProcessing complete. Saved {processed_count} images to '{OUTPUT_DIRECTORY}'.")